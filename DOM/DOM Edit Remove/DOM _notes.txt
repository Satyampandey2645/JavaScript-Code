âœ… Why addOptiLanguage() is more efficient than addLanguage()

1. innerHTML â†’ Browser has to re-parse HTML
When you use this:
    li.innerHTML = `${langName}`;

The browser thinks:
    â€œHmm, the developer gave me some HTML.
    I must parse it, check if there are tags, rebuild the internal structure.â€

Even if it's just text, the browser still treats it like HTML and re-parses everything.

This is slower because:
  -> It scans the string character by character
  -> Checks for <tags>
  -> Builds DOM nodes again

So innerHTML touches the whole internal tree of that element.    


2. createTextNode â†’ Direct text, no HTML parsing
When you do:
    li.appendChild(document.createTextNode(langName));

Browser thinks:
  -> â€œOh! Pure text!
  -> Just put it inside the element.
  -> No need to check for HTML, no need to rebuild anything.â€

It simply creates a text node and inserts it.
No re-parsing, no tree rebuilding.


ğŸ§  Short Summary:

| Method           | What happens                          | Fast or Slow? |
| ---------------- | ------------------------------------- | ------------- |
| `innerHTML`      | Browser re-parses your string as HTML |    Slower     |
| `createTextNode` | Directly inserts text without parsing |    Faster     |


ğŸ’¡ Easy Example (Real Life Analogy)
Using innerHTML is like:
    You want to add one word to a notebookâ€¦
    But instead, you rewrite the entire page after checking every letter again.

Using createTextNode is like:
    Just write the new word at the end of the page.
    No checking, no re-writing.

âœ”ï¸ Thatâ€™s why addOptiLanguage() is more efficient.

--------------------------------------------------- In more Simple way ---------------------------------------------------

âœ… innerHTML works, but it does more work internally
When you write:
    li.innerHTML = langName;

The browser does this:
  1. Deletes anything already inside the element (even if empty).
  2. Parses the string you gave.
  3. Checks for HTML tags, attributes, structure.
  4. Rebuilds DOM nodes from that HTML.

Even if your string is "JavaScript", it still checks:
  Is there <b>?
  Is there <div>?
  Is there <script>?
  Is this HTML?
  How do I build this?

This takes extra time â€” but for small apps, it's so fast you don't even notice.
That's why it works, and works well.


âœ… createTextNode does only one thing
    li.appendChild(document.createTextNode(langName));

Browser does this:
    â€œOh, plain text? Just put it inside.â€

No parsing
No scanning
No checking
No rebuilding DOM

This is why itâ€™s more efficient.

ğŸ§  Simple Analogy:
innerHTML = scanning whole exam paper
   Even if you write 1 line, the teacher scans the whole paper again.

createTextNode = just writing one line
   You write one line, done.
   Teacher doesnâ€™t scan everything.


ğŸ”¥ Final truth:
  ğŸ’¡ innerHTML works â€” and for small tasks, it is totally fine.
  ğŸ’¡ But createTextNode is safer, faster, and avoids unnecessary processing.

Use innerHTML when:
   * You actually want to insert HTML (with <b>, <div>, etc.)

Use createTextNode when:
   * You only want to insert plain text efficiently.
