ğŸ§  What is an Execution Context?
An Execution Context (EC) is like a box or environment where JavaScript code is evaluated and executed.
It defines how variables, functions, and the this keyword are managed.

Whenever your code runs, JavaScript creates an Execution Context to keep track of everything happening during execution.

ğŸ” Types of Execution Contexts
There are three main types:
1. Global Execution Context (GEC)
2. Function Execution Context (FEC)
3. Eval Execution Context (used rarely, for code inside eval())


1ï¸âƒ£ Global Execution Context (GEC)
* Created when the JS engine starts executing your script (the first thing that runs).
* It:
  -> Creates a global object (window in browser, global in Node.js)
  -> Sets this to the global object
  -> Allocates memory for all global variables and functions

  Example:  let a = 10;
            function greet() {
                console.log("Hello, Satyam!");
            }

            Here:
            -> GEC is created first.
            -> Memory is allocated for a and greet (but not executed yet).


2ï¸âƒ£ Function Execution Context (FEC)
Whenever a function is called, a new execution context is created for that function.

Example:  function greet() {
            let name = "Satyam";
            console.log("Hello, " + name);
          }

          greet();

          Here:
          When greet() is called:
          -> A new FEC is created.
          -> It has its own memory space (for local variables and arguments).
          -> After the function finishes, its FEC is destroyed.
           

ğŸ§© Each Execution Context has two main phases
1. Creation Phase
   JS engine sets up the environment:
   * Creates a variable object (VO)
   * Sets up the scope chain
   * Determines this value
   * Memory is allocated for variables and functions
     -> Variables are set to undefined
     -> Functions are stored as references

2. Execution Phase
   * Code is executed line by line.
   * Variable values are assigned.
   * Function calls are made (creating new FECs).


ğŸ§± Execution Stack (Call Stack)
All Execution Contexts are managed using a stack structure (LIFO).

Example:  function first() {
            console.log("Inside first");
            second();
          }

          function second() {
              console.log("Inside second");
          }

          first();
          console.log("Done!");

Step-by-step flow:
* Global Execution Context â†’ pushed first
* first() â†’ creates new FEC â†’ pushed
* second() â†’ creates new FEC â†’ pushed
* second() finishes â†’ popped
* first() finishes â†’ popped
* Finally, GEC is popped â†’ program ends

ğŸ§  Stack at different moments:
| second() FEC |
| first()  FEC |
| Global  EC   |


âš™ï¸ Visualization Summary:

| Phase             | What Happens                                                        |
| ----------------- | ------------------------------------------------------------------- |
| Creation          | Memory is allocated (`undefined` for vars, full function for funcs) |
| Execution         | Code runs line by line, values are assigned                         |
| After Execution   | Function EC is popped off the stack                                 |


ğŸ§© Example to Combine All Concepts:

let x = 10;
function outer() {
    let y = 20;
    function inner() {
        let z = 30;
        console.log(x + y + z);
    }
    inner();
}
outer();

Execution Flow:
1. Global EC created â†’ x, outer stored.
2. When outer() runs â†’ new FEC (outer) created.
3. Inside it, inner() is called â†’ new FEC (inner) created.
4. JS resolves variables using scope chain:
   * z â†’ inner
   * y â†’ outer
   * x â†’ global
5. After printing 60, inner and outer ECs are popped.


ğŸ§© In Short:

| Term                  | Meaning                                |
| --------------------- | -------------------------------------- |
| Execution Context     | The environment where code runs        |
| Global EC             | Default context for entire script      |
| Function EC           | Created each time a function is called |
| Execution Stack       | Manages all ECs (LIFO)                 |
| Phases                | Creation â†’ Execution                   |

-------------------------------------------------------------------------------------------------------------------------

ğŸ§© Example Code:
let a = 10;
function first() {
    console.log("Inside first");
    second();
}

function second() {
    console.log("Inside second");
}

first();
console.log("Done!");


ğŸ§  Step-by-Step Execution Flow:

Step 1: Code starts running
ğŸ§± Global Execution Context (GEC) is created.

Memory Creation Phase:

| Variable | Memory Value       |
| -------- | ------------------ |
| `a`      | `undefined`        |
| `first`  | function reference |
| `second` | function reference |

âœ… this â†’ global object (window in browser)
âœ… Global EC is pushed to the Call Stack

Call Stack:
| Global EC |

Step 2: Execution Phase of Global EC
â¡ï¸ a = 10
â¡ï¸ first() is called â†’ new Function Execution Context (FEC) is created for first

New Context Created:
* Memory for local variables and this
* Execution context for first() pushed to the stack

Call Stack:
| first() EC |
| Global EC  |

Step 3: Inside first()
ğŸ–¥ console.log("Inside first") â†’ prints âœ… Inside first
â¡ï¸ Then second() is called
   â†’ New FEC for second() is created and pushed onto the stack.

Call Stack:
| second() EC |
| first() EC  |
| Global EC   |

Step 4: Inside second()
ğŸ–¥ console.log("Inside second") â†’ prints âœ… Inside second
âœ… Function second() completes â†’ its EC is popped from the stack.

Call Stack:
| first() EC  |
| Global EC   |

Step 5: Return to first()
After second() finishes, control goes back to first().
âœ… first() completes â†’ its EC is popped.

Call Stack:
| Global EC |

Step 6: Back to Global Context
Now JS executes the remaining line:
   console.log("Done!");
   âœ… Prints Done!
Program ends â†’ Global EC is finally popped off the stack.

Call Stack:
(empty)

ğŸ§­ Final Visualization Summary:

                     â¬‡ï¸ Start Program
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚      Global EC created    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ï¸
               first() is called
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚     first() EC created    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ï¸
               second() is called
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚     second() EC created   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ï¸
              second() finishes
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   first() EC removed      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ï¸
           Global EC removed â†’ End âœ…


ğŸ§© Key Takeaways:

| Concept                | Meaning                                 |
| ---------------------- | --------------------------------------- |
| Execution Context      | Environment for executing JS code       |
| Global EC              | Created first, destroyed last           |
| Function EC            | Created every time a function is called |
| Call Stack             | Manages contexts (LIFO order)           |
| When function ends     | Its EC is popped from stack             |

-------------------------------------------------------------------------------------------------------------------------

ğŸ§© Example Code:
let a = 5;

function outer() {
    let b = 10;

    function inner() {
        let c = 15;
        console.log(a + b + c);
    }

    inner();
}

outer();

ğŸ§  Step-by-Step Explanation:
Step 1 â€” Program starts
âœ… JavaScript engine creates the Global Execution Context (GEC).

Memory Phase (Hoisting):

| Variable | Value              |
| -------- | ------------------ |
| `a`      | `undefined`        |
| `outer`  | function reference |

Then the Execution Phase begins:
* a = 5
* outer() is called â†’ new Execution Context created

ğŸ“¦ Stack now:
| outer() EC |
| Global EC  |

Step 2 â€” Inside outer()
* A new Function Execution Context (FEC) is created for outer.

Memory setup:

| Variable | Value              |
| -------- | ------------------ |
| `b`      | `undefined`        |
| `inner`  | function reference |

Then during execution:
* b = 10
* inner() is called â†’ new FEC created for it

ğŸ“¦ Stack now:
| inner() EC |
| outer() EC |
| Global EC  |

Step 3 â€” Inside inner()
Memory setup:
| Variable | Value       |
| -------- | ----------- |
| `c`      | `undefined` |

Then:
* c = 15
* Executes console.log(a + b + c)

âœ… JavaScript looks for variables:
* c â†’ found in inner
* b â†’ found in outer
* a â†’ found in global

ğŸ“¤ Output â†’ 30

âœ… inner() completes â†’ popped from stack.

ğŸ“¦ Stack now:
| outer() EC |
| Global EC  |

Step 4 â€” Back to outer()
inner() is done, now outer() completes too â†’ popped from stack.

ğŸ“¦ Stack now:
| Global EC |

Step 5 â€” Global Ends
All code done âœ… â†’ Global EC is popped â†’ Stack empty.

ğŸ“¦ Stack now:
(empty)

ğŸ§­ Call Stack Animation
Letâ€™s visualize the call stack flow step-by-step ğŸ‘‡

                Step 1: Start
                | Global EC |
                ---------------------

                Step 2: outer() is called
                | outer() EC |
                | Global EC  |
                ---------------------

                Step 3: inner() is called
                | inner() EC |
                | outer() EC |
                | Global EC  |
                ---------------------

                Step 4: inner() finishes
                | outer() EC |
                | Global EC  |
                ---------------------

                Step 5: outer() finishes
                | Global EC |
                ---------------------

                Step 6: Program ends âœ…
                | (empty) |
                ---------------------

ğŸ§© Whatâ€™s Happening Behind the Scenes:

| Phase               | Description                                                                 |
| ------------------- | --------------------------------------------------------------------------- |
| Creation Phase      | Memory allocated for variables (`undefined`) and function references stored |
| Execution Phase     | Values assigned, functions called, and console logs executed                |
| Scope Chain         | JS engine searches variable names upward (inner â†’ outer â†’ global)           |
| Stack Order         | Last In â†’ First Out (LIFO)                                                  |

ğŸ” Key Concept Visualization:
inner()
  â¬†ï¸ needs b â†’ from outer()
  â¬†ï¸ needs a â†’ from global()

So JavaScript climbs up the Scope Chain to find them.

-------------------------------------------------------------------------------------------------------------------------

ğŸ§© Code Recap:
let a = 5;

function outer() {
    let b = 10;

    function inner() {
        let c = 15;
        console.log(a + b + c);
    }

    inner();
}

outer();

ğŸ§± 1ï¸âƒ£ Step 1 â€“ Global Execution Context (GEC)
When the script starts, JS engine creates the Global Execution Context.
ğŸŒ Global Scope:
a = 5
outer = function reference

ğŸ“¦ Call Stack:
| Global EC |
Everything lives here initially.

ğŸ§± 2ï¸âƒ£ Step 2 â€“ outer() is called
When outer() runs â†’ JS creates a new Function Execution Context (FEC) for it.

ğŸ§  Memory inside outer:
b = 10
inner = function reference

ğŸ“¦ Call Stack:
| outer() EC |
| Global EC  |

ğŸ”— Scope Chain for outer():
outer() â†’ Global
It can access its own variables + global ones.

ğŸ§± 3ï¸âƒ£ Step 3 â€“ inner() is called
Now, inner() executes â†’ new Function Execution Context created.

ğŸ§  Memory inside inner:
c = 15

ğŸ“¦ Call Stack:
| inner() EC |
| outer() EC |
| Global EC  |

ğŸ”— Scope Chain for inner():
inner() â†’ outer() â†’ global
So, when it runs console.log(a + b + c), hereâ€™s what happens ğŸ‘‡

| Variable | Found In | Scope Level           |
| -------- | -------- | --------------------- |
| `c`      | inner()  | local scope           |
| `b`      | outer()  | parent function scope |
| `a`      | global   | global scope          |

âœ… Total = 5 + 10 + 15 = 30

ğŸ“Š 4ï¸âƒ£ Visual Diagram â€” Stack + Scope Chain Together

                 ğŸ”— SCOPE CHAIN (variable lookup path)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 | Global Scope:                                      |
 |   a = 5                                            |
 |   outer() {...}                                    |
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–²
               â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 | outer() Scope:                                     |
 |   b = 10                                           |
 |   inner() {...}                                    |
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–²
               â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 | inner() Scope:                                     |
 |   c = 15                                           |
 |   console.log(a + b + c); â†’ finds values upward â†‘  |
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“¦ Call Stack at runtime (bottom â†’ top):
| inner() EC |   â† currently executing
| outer() EC |
| Global EC  |

ğŸ§­ 5ï¸âƒ£ Step 4 â€“ Cleanup
After inner() finishes:
* Itâ€™s popped off the stack.
* Then outer() finishes â†’ popped.
* Finally, Global EC â†’ popped.
ğŸ“¦ Stack becomes empty â†’ Program ends âœ…

ğŸ§© Key Takeaways (Interview Ready):

| Concept               | Meaning                                                         |
| --------------------- | --------------------------------------------------------------- |
| Call Stack            | Tracks *where* code execution currently is                      |
| Scope Chain           | Defines *how variables are found* (inner â†’ outer â†’ global)      |
| Execution Context     | Box that stores functionâ€™s variables, `this`, and scope info    |
| LIFO                  | Last function called â†’ first one to finish                      |
| Lexical Scope         | Inner functions can access outer variables (but not vice versa) |










